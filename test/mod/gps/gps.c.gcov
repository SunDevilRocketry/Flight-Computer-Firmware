        -:    0:Source:../../../mod/gps/gps.c
        -:    0:Graph:build/gps.gcno
        -:    0:Data:build/gps.gcda
        -:    0:Runs:12
        -:    1:/*******************************************************************************
        -:    2:*
        -:    3:* FILE: 
        -:    4:* 		gps.c
        -:    5:*
        -:    6:* DESCRIPTION: 
        -:    7:* 		Contains API functions for GPS 
        -:    8:*
        -:    9:*******************************************************************************/
        -:   10:
        -:   11:
        -:   12:/*------------------------------------------------------------------------------
        -:   13: Standard Includes  
        -:   14:------------------------------------------------------------------------------*/
        -:   15:
        -:   16:
        -:   17:/*------------------------------------------------------------------------------
        -:   18: MCU Pins 
        -:   19:------------------------------------------------------------------------------*/
        -:   20:#if   defined( FLIGHT_COMPUTER      )
        -:   21:	#include "sdr_pin_defines_A0002.h"
        -:   22:#elif defined( ENGINE_CONTROLLER    )
        -:   23:	#include "sdr_pin_defines_L0002.h"
        -:   24:#elif defined( VALVE_CONTROLLER     )
        -:   25:	#include "sdr_pin_defines_L0005.h"
        -:   26:#elif defined( GROUND_STATION       )
        -:   27:	#include "sdr_pin_defines_A0005.h"
        -:   28:#elif defined( FLIGHT_COMPUTER_LITE )
        -:   29:	#include "sdr_pin_defines_A0007.h"
        -:   30:#endif
        -:   31:
        -:   32:
        -:   33:/*------------------------------------------------------------------------------
        -:   34: Project Includes                                                               
        -:   35:------------------------------------------------------------------------------*/
        -:   36:#include "main.h"
        -:   37:#include "gps.h"
        -:   38:#include <string.h>
        -:   39:#include <stdlib.h>
        -:   40:#include <stdio.h>
        -:   41:
        -:   42:/*------------------------------------------------------------------------------
        -:   43: Preprocesor Directives 
        -:   44:------------------------------------------------------------------------------*/
        -:   45:
        -:   46:/*------------------------------------------------------------------------------
        -:   47:Global Variables                                                                  
        -:   48:------------------------------------------------------------------------------*/
        -:   49:
        -:   50:/*------------------------------------------------------------------------------
        -:   51: Procedures 
        -:   52:------------------------------------------------------------------------------*/
        -:   53:
        -:   54:
        -:   55:/*******************************************************************************
        -:   56:*                                                                              *
        -:   57:* PROCEDURE:                                                                   * 
        -:   58:* 		gps_transmit                                                    *
        -:   59:*                                                                              *
        -:   60:* DESCRIPTION:                                                                 * 
        -:   61:* 		transmits a specified number of bytes over USB                         *
        -:   62:*                                                                              *
        -:   63:*******************************************************************************/
    #####:   64:GPS_STATUS gps_transmit 
        -:   65:	(
        -:   66:    void*    tx_data_ptr , /* Data to be sent       */	
        -:   67:	size_t   tx_data_size, /* Size of transmit data */ 
        -:   68:	uint32_t timeout       /* UART timeout          */
        -:   69:	)
        -:   70:{
        -:   71:/*------------------------------------------------------------------------------
        -:   72: Local Variables
        -:   73:------------------------------------------------------------------------------*/
    #####:   74:HAL_StatusTypeDef gps_status;
        -:   75:
        -:   76:
        -:   77:/*------------------------------------------------------------------------------
        -:   78: API Function Implementation 
        -:   79:------------------------------------------------------------------------------*/
        -:   80:
        -:   81:/* Transmit byte */
    #####:   82:gps_status = HAL_UART_Transmit( &( GPS_HUART ),
        -:   83:                                tx_data_ptr   , 
        -:   84:                                tx_data_size  , 
        -:   85:                                timeout );
        -:   86:
        -:   87:/* Return HAL status */
    #####:   88:if ( gps_status != HAL_OK )
        -:   89:	{
        -:   90:	return gps_status;
        -:   91:	}
        -:   92:else
        -:   93:	{
    #####:   94:	return GPS_OK;
        -:   95:	}
        -:   96:
        -:   97:} /* usb_transmit */
        -:   98:
        -:   99:
        -:  100:/*******************************************************************************
        -:  101:*                                                                              *
        -:  102:* PROCEDURE:                                                                   *
        -:  103:* 		usb_recieve                                                           *
        -:  104:*                                                                              *
        -:  105:* DESCRIPTION:                                                                 *
        -:  106:* 	    Receives bytes from the USB port                                       *
        -:  107:*                                                                              *
        -:  108:*******************************************************************************/
    #####:  109:GPS_STATUS gps_receive 
        -:  110:	(
        -:  111:	void*    rx_data_ptr , /* Buffer to export data to        */
        -:  112:	size_t   rx_data_size, /* Size of the data to be received */
        -:  113:	uint32_t timeout       /* UART timeout */
        -:  114:	)
        -:  115:{
        -:  116:/*------------------------------------------------------------------------------
        -:  117: Local Variables
        -:  118:------------------------------------------------------------------------------*/
    #####:  119:HAL_StatusTypeDef gps_status;
        -:  120:
        -:  121:
        -:  122:/*------------------------------------------------------------------------------
        -:  123: API Function Implementation 
        -:  124:------------------------------------------------------------------------------*/
        -:  125:
        -:  126:/* Transmit byte */
    #####:  127:gps_status = HAL_UART_Receive( &( GPS_HUART ),
        -:  128:                               rx_data_ptr   , 
        -:  129:                               rx_data_size  , 
        -:  130:                               timeout );
        -:  131:/* Return HAL status */
    #####:  132:switch ( gps_status )
        -:  133:	{
        -:  134:	case HAL_TIMEOUT:
        -:  135:		{
        -:  136:		return GPS_TIMEOUT;
    #####:  137:		break;
        -:  138:		}
    #####:  139:	case HAL_OK:
        -:  140:		{
    #####:  141:		return GPS_OK;
    #####:  142:		break;
        -:  143:		}
    #####:  144:	default:
        -:  145:		{
    #####:  146:		return GPS_FAIL;
    #####:  147:		break;
        -:  148:        }
        -:  149:	}
        -:  150:
        -:  151:} /* usb_receive */
        -:  152:
        -:  153:
        -:  154:/*******************************************************************************
        -:  155:*                                                                              *
        -:  156:* PROCEDURE:                                                                   *
        -:  157:* 		usb_recieve_IT                                                         *
        -:  158:*                                                                              *
        -:  159:* DESCRIPTION:                                                                 *
        -:  160:* 	    Receives bytes from the USB port                                       *
        -:  161:*                                                                              *
        -:  162:*******************************************************************************/
    #####:  163:GPS_STATUS gps_receive_IT 
        -:  164:	(
        -:  165:	uint8_t*    rx_data_ptr , /* Buffer to export data to        */
        -:  166:	size_t   rx_data_size /* Size of the data to be received */
        -:  167:	)
        -:  168:{
        -:  169:/*------------------------------------------------------------------------------
        -:  170: Local Variables
        -:  171:------------------------------------------------------------------------------*/
    #####:  172:HAL_StatusTypeDef gps_status;
        -:  173:
        -:  174:
        -:  175:/*------------------------------------------------------------------------------
        -:  176: API Function Implementation 
        -:  177:------------------------------------------------------------------------------*/
        -:  178:
        -:  179:/* Transmit byte */
    #####:  180:gps_status = HAL_UART_Receive_IT( &( GPS_HUART ),
        -:  181:                               rx_data_ptr   , 
        -:  182:                               rx_data_size );
        -:  183:
        -:  184:/* Return HAL status */
    #####:  185:switch ( gps_status )
        -:  186:	{
        -:  187:	case HAL_TIMEOUT:
        -:  188:		{
        -:  189:		return GPS_TIMEOUT;
    #####:  190:		break;
        -:  191:		}
    #####:  192:	case HAL_OK:
        -:  193:		{
    #####:  194:		return GPS_OK;
    #####:  195:		break;
        -:  196:		}
    #####:  197:	default:
        -:  198:		{
    #####:  199:		return GPS_FAIL;
    #####:  200:		break;
        -:  201:        }
        -:  202:	}
        -:  203:
        -:  204:} /* usb_receive_IT */
        -:  205:
        -:  206:/*******************************************************************************
        -:  207:*                                                                              *
        -:  208:* PROCEDURE:                                                                   *
        -:  209:* 		gps_mesg_validate                                                         *
        -:  210:*                                                                              *
        -:  211:* DESCRIPTION:                                                                 *
        -:  212:* 	    Validate message returned from GPS                                       *
        -:  213:*                                                                              *
        -:  214:*******************************************************************************/
       30:  215:int gps_mesg_validate(char *nmeastr){
       30:  216:    char check[3];
       30:  217:    char checkcalcstr[3];
       30:  218:    int i;
       30:  219:    int calculated_check;
        -:  220:
       30:  221:    i=0;
       30:  222:    calculated_check=0;
        -:  223:
        -:  224:    // check to ensure that the string starts with a $
       30:  225:    if(nmeastr[i] == '$')
        -:  226:        i++;
        -:  227:    else
        -:  228:        return 0;
        -:  229:
        -:  230:    //No NULL reached, 75 char largest possible NMEA message, no '*' reached
     1643:  231:    while((nmeastr[i] != 0) && (nmeastr[i] != '*') && (i < 75)){
     1613:  232:        calculated_check ^= nmeastr[i];// calculate the checksum
     1613:  233:        i++;
        -:  234:    }
        -:  235:
       30:  236:    if(i >= 75){
        -:  237:        return 0;// the string was too long so return an error
        -:  238:    }
        -:  239:
       27:  240:    if (nmeastr[i] == '*'){
       23:  241:        check[0] = nmeastr[i+1];    //put hex chars in check string
       23:  242:        check[1] = nmeastr[i+2];
       23:  243:        check[2] = 0;
        -:  244:    }
        -:  245:    else
        -:  246:        return 0;// no checksum separator found there for invalid
        -:  247:
       23:  248:    sprintf(checkcalcstr,"%02X",calculated_check);
       23:  249:    return((checkcalcstr[0] == check[0])
       23:  250:        && (checkcalcstr[1] == check[1])) ? 1 : 0 ;
        -:  251:} /*gps_mesg_validate*/
        -:  252:
        -:  253:/*******************************************************************************
        -:  254:*                                                                              *
        -:  255:* PROCEDURE:                                                                   *
        -:  256:* 		GPS_parse                                                              *
        -:  257:*                                                                              *
        -:  258:* DESCRIPTION:                                                                 *
        -:  259:* 	    Convert raw NMEA string to usable data                                 *
        -:  260:*                                                                              *
        -:  261:* TEST:                                                                        *
        -:  262:*       test_GPS_parse provides coverage. If this function or its              *
        -:  263:*       helpers are updated, make sure the test cases are updated to match.    *
        -:  264:*                                                                              *
        -:  265:*******************************************************************************/
      168:  266:void GPS_parse(GPS_DATA* gps_ptr, char *GPSstrParse){
        -:  267:/* Get message type */
      168:  268:char token[8]; // Needs to be 8 chars for memory alignment
      168:  269:strncpy(token, GPSstrParse, 6);
      168:  270:token[7] = '\0';
      168:  271:int idx = 7;
      168:  272:memset(gps_ptr, 0, sizeof(GPS_DATA));
        -:  273:
        -:  274:/* Parse by message type */
      168:  275:if (!strcmp(token, "$GPGGA")) 
        -:  276:    {
       48:  277:    gps_ptr->utc_time = gps_string_to_float(GPSstrParse, &idx);
       48:  278:    gps_ptr->nmea_latitude = gps_string_to_float(GPSstrParse, &idx);
       48:  279:    gps_ptr->ns = gps_string_to_char(GPSstrParse, &idx);
       48:  280:    gps_ptr->nmea_longitude = gps_string_to_float(GPSstrParse, &idx);
       48:  281:    gps_ptr->ew = gps_string_to_char(GPSstrParse, &idx);
       48:  282:    gps_ptr->lock = gps_string_to_char(GPSstrParse, &idx);
       48:  283:    gps_ptr->satelites = (int)(gps_string_to_float(GPSstrParse, &idx) + 0.5); // This is a decimal number.
       48:  284:    gps_ptr->hdop = gps_string_to_float(GPSstrParse, &idx);
       48:  285:    gps_ptr->msl_altitude = gps_string_to_float(GPSstrParse, &idx);
       48:  286:    gps_ptr->msl_units = gps_string_to_char(GPSstrParse, &idx);
        -:  287:    }
      120:  288:else if (!strcmp(token, "$GPRMC")) 
        -:  289:    {
       60:  290:    gps_ptr->utc_time = gps_string_to_float(GPSstrParse, &idx);
       60:  291:    gps_ptr->rmc_status = gps_string_to_char(GPSstrParse, &idx); /* unused */
       60:  292:    gps_ptr->nmea_latitude = gps_string_to_float(GPSstrParse, &idx);
       60:  293:    gps_ptr->ns = gps_string_to_char(GPSstrParse, &idx);
       60:  294:    gps_ptr->nmea_longitude = gps_string_to_float(GPSstrParse, &idx);
       60:  295:    gps_ptr->ew = gps_string_to_char(GPSstrParse, &idx);
       60:  296:    gps_ptr->speed_k = gps_string_to_float(GPSstrParse, &idx);
       60:  297:    gps_ptr->course_d = gps_string_to_float(GPSstrParse, &idx);
       60:  298:    gps_ptr->date = (int)(0.5 + gps_string_to_float(GPSstrParse, &idx));
        -:  299:    }
       60:  300:else if (!strcmp(token, "$GPGLL")) 
        -:  301:    {
       23:  302:    gps_ptr->nmea_latitude = gps_string_to_float(GPSstrParse, &idx);
       23:  303:    gps_ptr->ns = gps_string_to_char(GPSstrParse, &idx);
       23:  304:    gps_ptr->nmea_longitude = gps_string_to_float(GPSstrParse, &idx);
       23:  305:    gps_ptr->ew = gps_string_to_char(GPSstrParse, &idx);
       23:  306:    gps_ptr->utc_time = gps_string_to_float(GPSstrParse, &idx);
       23:  307:    gps_ptr->gll_status = gps_string_to_char(GPSstrParse, &idx);
        -:  308:    }
       37:  309:else if (!strcmp(token, "$GPVTG")) 
        -:  310:    {
       24:  311:    gps_ptr->course_t = gps_string_to_float(GPSstrParse, &idx);
       24:  312:    gps_ptr->course_t_unit = gps_string_to_char(GPSstrParse, &idx);
       24:  313:    gps_ptr->course_m = gps_string_to_float(GPSstrParse, &idx);
       24:  314:    gps_ptr->course_m_unit = gps_string_to_char(GPSstrParse, &idx);
       24:  315:    gps_ptr->speed_k = gps_string_to_float(GPSstrParse, &idx);
       24:  316:    gps_ptr->speed_k_unit = gps_string_to_char(GPSstrParse, &idx);
       24:  317:    gps_ptr->speed_km = gps_string_to_float(GPSstrParse, &idx);
       24:  318:    gps_ptr->speed_km_unit = gps_string_to_char(GPSstrParse, &idx);
        -:  319:    }
      168:  320:} /* GPS_parse */
        -:  321:
        -:  322:/*******************************************************************************
        -:  323:*                                                                              *
        -:  324:* PROCEDURE:                                                                   *
        -:  325:* 		gps_string_to_float                                                    *
        -:  326:*                                                                              *
        -:  327:* DESCRIPTION:                                                                 *
        -:  328:* 	    Convert part of an NMEA string to a float                              *
        -:  329:*                                                                              *
        -:  330:* TEST:                                                                        *
        -:  331:*       test_GPS_parse provides coverage. If this function is                  *
        -:  332:*       updated, please re-run the test and update if necessary                *
        -:  333:*                                                                              *
        -:  334:*******************************************************************************/
      813:  335:static float gps_string_to_float(char *GPSstrParse, int* inputIdx) 
        -:  336:{
      813:  337:int idx = *inputIdx;
      813:  338:char currChar = GPSstrParse[idx];
      813:  339:char tempstr[16];
      813:  340:int tempidx = 0;
      813:  341:if (GPSstrParse[idx] == ',') /* Checks if subsequent comma */
        -:  342:    {
       45:  343:    *inputIdx = *inputIdx + 1;
       45:  344:    return 0.0f; /* null return */
        -:  345:    }
     6104:  346:while (currChar != ',') 
        -:  347:    {
     5336:  348:    if (tempidx > 15) 
        -:  349:        {
        -:  350:        /* ERROR HANDLING */
        -:  351:        // maybe just exit loop? and deal with bad data? or make it null.
        -:  352:        return 0.0f;
        -:  353:        }
     5336:  354:    tempstr[tempidx] = GPSstrParse[idx];
     5336:  355:    tempidx++;
     5336:  356:    idx++;
     5336:  357:    currChar = GPSstrParse[idx];
        -:  358:    }
      768:  359:*inputIdx = idx + 1;
      768:  360:tempstr[tempidx] = '\0';
      768:  361:return strtof(tempstr, NULL);
        -:  362:} /* gps_string_to_float */
        -:  363:
        -:  364:/*******************************************************************************
        -:  365:*                                                                              *
        -:  366:* PROCEDURE:                                                                   *
        -:  367:* 		gps_string_to_char                                                     *
        -:  368:*                                                                              *
        -:  369:* DESCRIPTION:                                                                 *
        -:  370:* 	    Get a char from an NMEA string if it exists                            *
        -:  371:*                                                                              *
        -:  372:* TEST:                                                                        *
        -:  373:*       test_GPS_parse provides coverage. If this function is                  *
        -:  374:*       updated, please re-run the test and update if necessary                *
        -:  375:*                                                                              *
        -:  376:*******************************************************************************/
      537:  377:static char gps_string_to_char(char *GPSstrParse, int* inputIdx) 
        -:  378:{
      537:  379:int idx = *inputIdx;
      537:  380:char currChar = GPSstrParse[idx];
      537:  381:if (GPSstrParse[idx] == ',') /* Checks if subsequent comma */
        -:  382:    {
       21:  383:    *inputIdx = *inputIdx + 1;
       21:  384:    return 0; /* null return */
        -:  385:    }
        -:  386:else 
        -:  387:    {
      516:  388:    *inputIdx = *inputIdx + 2;
      516:  389:    return GPSstrParse[idx];
        -:  390:    }
        -:  391:} /* gps_string_to_char */
        -:  392:
        -:  393:/*******************************************************************************
        -:  394:* END OF FILE                                                                  * 
        -:  395:*******************************************************************************/
